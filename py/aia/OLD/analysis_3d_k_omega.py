#
# Further analysis and plots based on the k-omega data generated by
# analysis_3d_fft.py
#
import os
import pickle
import numpy as np
from scipy.ndimage.filters import gaussian_filter
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import astropy.units as u

import details_plots as dp

from details_plots import log_10_product

plt.ion()

# Frequency units
frequency_unit = dp.fz

sources = {"BM4D": {"file_path": os.path.expanduser("~/ts/noise_reduction/analysis_3d_fft.BM4D.logx=True.logy=True.nipy_spectral.png.pkl")},
           "BM3D": {"file_path": os.path.expanduser("~/ts/noise_reduction/analysis_3d_fft.BM3D.logx=True.logy=True.nipy_spectral.png.pkl")},
           "PSF_removed": {"file_path": os.path.expanduser("~/ts/noise_reduction/analysis_3d_fft.PSF_removed.logx=True.logy=True.nipy_spectral.png.pkl")},
           "no_denoise": {"file_path": os.path.expanduser("~/ts/noise_reduction/analysis_3d_fft.no_denoise.logx=True.logy=True.nipy_spectral.png.pkl")}}

# Load data
for source in sources.keys():
    file_path = sources[source]["file_path"]
    print("loading {:s}".format(file_path))
    f = open(file_path, 'rb')
    sources[source]["k_omega_power"] = pickle.load(f)
    sources[source]["wn"] = pickle.load(f)
    sources[source]["spm"] = pickle.load(f)
    f.close()

#
# Compare mean powers across different image processing
#

# Pick how we are going to analyze the data
for mean_style, mean_style_label in enumerate(('mean Fourier power', 'mean log10(Fourier power)')):

    # Pick which quantity we want to plot
    for axis, data_type in enumerate(('wavenumber', 'frequency')):

        # Start the plot
        plt.close('all')
        fig, ax = plt.subplots()
        ax.set_xscale('log')
        ax.xaxis.set_major_formatter(plt.FuncFormatter(log_10_product))

        ax.set_yscale('log')
        ax.set_ylabel('Fourier power')

        if data_type == 'frequency':
            f5 = ax.axvline(dp.five_minutes.frequency.to(frequency_unit).value,
                            linestyle=dp.five_minutes.linestyle,
                            color=dp.five_minutes.color,
                            label=dp.five_minutes.label)
            f3 = ax.axvline(dp.three_minutes.frequency.to(frequency_unit).value,
                            linestyle=dp.three_minutes.linestyle,
                            color=dp.three_minutes.color,
                            label=dp.three_minutes.label)
            xlabel_unit = frequency_unit
        else:
            xlabel_unit = '1/arcsec'

        ax.set_xlabel(data_type + " [{:s}]".format(xlabel_unit))

        # Go through all the data sources
        for source in sources:

            k_omega_power = sources[source]["k_omega_power"]
            spm = sources[source]["spm"]
            wn = sources[source]["wn"]

            if mean_style == 0:
                mean_power = np.mean(k_omega_power, axis=axis)
            else:
                mean_power = np.exp(np.mean(np.log(k_omega_power), axis=axis))

            if axis == 0:
                xaxis = wn.value
            else:
                xaxis = spm[0, :].to(frequency_unit).value

            # Plot mean power
            ax.plot(xaxis, mean_power, label=source)
            ax.set_title(source + '\n{:s}'.format(mean_style_label))

        ax.legend(fontsize=8.0, framealpha=0.5)
        fig.tight_layout()
        fig.savefig(file_path + '.compare.{:s}.{:s}.png'.format(mean_style_label, data_type))


def ratio_power(source1, source2, log_y_axis=True, log_x_axis=True,
                frequency_unit=u.mHz, wavenumber_unit=1.0/u.arcsec,
                alfven_speed=1000*u.km/u.s,
                cmap=cm.Set1, file_path=os.path.expanduser('~/ts/noise_reduction/ratio_power')):

    # Ratio of  power
    powers_ratio = sources[source1]["k_omega_power"] / sources[source2]["k_omega_power"]
    print(np.min(powers_ratio), np.max(powers_ratio))

    # Axes
    wn = sources[source1]["wn"].to(wavenumber_unit).value
    spm = sources[source1]["spm"][0, :].to(frequency_unit).value

    # Oscillations
    five_minutes = dp.five_minutes.frequency.to(frequency_unit).value
    three_minutes = dp.three_minutes.frequency.to(frequency_unit).value

    # Plot of the ratio power.
    fig, ax = plt.subplots()
    if log_y_axis:
        yformatter = plt.FuncFormatter(log_10_product)
        ax.set_yscale('log')
        ax.yaxis.set_major_formatter(yformatter)
    if log_x_axis:
        xformatter = plt.FuncFormatter(log_10_product)
        ax.set_xscale('log')
        ax.xaxis.set_major_formatter(xformatter)
    #
    # Should also include a contour at powers_ratio = 1.0 to guide the eye
    # as to where the power ratio goes from above 1 (more power in the first
    # source) to less power (more power in the second source).
    #
    vmin = 10.00**-1.63
    vmax = 10.00**0.361
    norm = colors.LogNorm(vmin=vmin, vmax=vmax)
    cax = ax.pcolormesh(wn, spm, powers_ratio, cmap=cmap, norm=norm)

    # Now overplot a contour
    clevels = [0.125, 0.25, 0.5, 1.0]
    contour = ax.contour(wn, spm, gaussian_filter(powers_ratio, 2.0), levels=clevels, color='k', linestyle='--')
    csl = ax.clabel(contour)

    wavenumber_label = r'wavenumber ({:s}) [range={:f}$\rightarrow${:f}]'.format(str(wavenumber_unit), wn[0], wn[-1])
    frequency_label = r'frequency ({:s}) [range={:f}$\rightarrow${:f}]'.format(str(frequency_unit), spm[0], spm[-1])
    ax.set_xlabel(wavenumber_label)
    ax.set_ylabel(frequency_label)
    ax.set_xlim(wn[0], wn[-1])
    ax.set_ylim(spm[0], spm[-1])
    ax.set_title("power ratio {:s}/{:s}".format(source1, source2))
    f5 = ax.axhline(five_minutes,
                            linestyle=dp.five_minutes.linestyle,
                            color=dp.five_minutes.color, zorder=99)
    f3 = ax.axhline(three_minutes,
                            linestyle=dp.three_minutes.linestyle,
                            color=dp.three_minutes.color, zorder=99)
    clevels.insert(0, vmin)
    clevels.append(vmax)
    cb = fig.colorbar(cax, ticks=clevels, label='power ratio')
    cb.ax.set_yticklabels(['0.02', '0.125', '0.25', '0.5', '1.0', '2.3'])

    # Put in the Alfven speed line
    alfven_color = 'k'
    arcsec_per_km = (0.6 / 750.0) * u.arcsec/u.km
    alfven_line = (alfven_speed * arcsec_per_km * sources[source1]["wn"].to(wavenumber_unit)).to(frequency_unit).value
    alf, = ax.plot(wn, alfven_line, color=alfven_color, linewidth=5, zorder=100,
                   label=r'Alfven speed $v_{A}=$' + '{:s}'.format(str(alfven_speed)))

    # Alfven wave labels
    max_alfven_freq_index = 0
    while alfven_line[max_alfven_freq_index] < np.max(spm):
        max_alfven_freq_index += 1
    print(wn[max_alfven_freq_index/2], alfven_line[max_alfven_freq_index/2])
    ax.text(0.1, 1.0,
            r'$<v_{A}$', color=alfven_color, zorder=100, fontsize=24, fontweight='bold', horizontalalignment='right')
    ax.text(0.007, 15.0,
            r'$>v_{A}$', color=alfven_color, zorder=100, fontsize=24, fontweight='bold', horizontalalignment='left')

    ax.legend((f3,
               f5,
               alf),
              (dp.three_minutes.label,
               dp.five_minutes.label,
               'Alfven speed={:s}'.format(str(alfven_speed))),
              loc='lower left', fontsize=10.0, framealpha=0.5)

    fig.tight_layout()
    fig.savefig(file_path + '.ratio.{:s}.{:s}.png'.format(source1, source2))
    return fig
